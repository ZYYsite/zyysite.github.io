---
layout: post
title:  "Python3浅拷贝与深拷贝的区别和理解"
date:   2019-07-17
categories: Python
tags: python 基础知识 找工作必备
author: zyy
---

* content
{:toc}

## 前言

我们知道，python中的对象可分为可变类型和不可变类型。这两种对象在浅拷贝和深拷贝时有许多差异，需要我们了解和区分。

## 主要内容

对于浅拷贝和深拷贝，需要考虑两个问题：
1. 拷贝后，原对象的地址和新对象的地址是否相同；（根据**对象**是可变类型还是不可变类型来考虑）
2. 修改其中的元素的值，是否会对另一个对象的对应元素造成影响。（根据**对象的元素**是可变类型还是不可变类型来考虑）




## 浅拷贝

**使用copy模块里面的copy方法实现：**
1. 对于不可变类型 Number String Tuple,浅复制仅仅是地址指向，**不会开辟新空间**。
2. 对于可变类型List、Dictionary、Set，浅复制**会开辟新的空间地址(仅仅是最顶层开辟了新的空间，里层的元素地址还是一样的)**，进行浅拷贝。
3. 浅拷贝后，改变原始对象中为**可变类型**的元素的值，**会同时影响拷贝对象**；改变原始对象中为**不可变类型**的元素的值，**只有原始对象受影响**。（操作拷贝对象对原始对象也是同理）

```js
x1 = (1,3)                 #x1是tuple
x2=copy.copy(x1)
x1和x2的地址是一样的！
```

对于list、tuple、dict这些元素可为不可变类型也可为可变类型的对象来说，其中**不可变类型**的元素，浅拷贝只是对原对象的该元素**增加一个引用**而已。改变原变量的元素的值（即改变它指向的对象），**不会**对拷贝变量的元素指向的对象造成影响。

对于**可变类型**的元素，浅拷贝的新对象与原对象的**元素的地址都是同样的地址**，由于可变对象的性质，修改对象不会导致地址发生改变，改变原对象的可变对象元素也**会对新对象造成影响**！

```js
list1 = [11,12]
list2 = copy.copy(list1)
list1 is list2              输出False    
list1[1] is list2[1]        输出True
list1[1] = 10               输出list2 为[11, 12]
tup1 = (1,2,[3,4])
tup2 = copy.copy(tup1)
tup1 is tup2                输出True
tup1[2] is tup2[2]          输出True
tup1[2][1] = 5              输出tup2 为(1, 2, [3, 5])
```

## 深拷贝

**使用copy模块里面的deepcopy方法实现:**

1. 浅拷贝，除了顶层拷贝，还对子元素也进行了拷贝（本质上**递归浅拷贝**）
2. 经过深拷贝后，若原始对象**含有可变类型元素**，则**原始对象和拷贝对象自身的地址及其所有的可变类型元素地址都没有相同的了**。

对于不可变类型Number、String、Tuple,深复制依然是地址指向，**不会**开辟新空间拷贝值。但是我发现了一个**例外**：当对一个**只由不可变类型元素组成的tuple进行深拷贝**时，它的拷贝对象和源对象地址**相同**；当对一个**包含有可变类型元素的tuple进行深拷贝**时，它的拷贝对象和源对象地址是**不相同**的（应该是由于对其中的可变类型元素开辟了新的空间，变成了新的绑定关系，所以就新建了一个tuple对象）！**对任意的tuple对象进行浅拷贝时，它的拷贝对象和源对象地址都是一样的！**

```js
x1 = (1,2)
x2 = copy.deepcopy(x1)
x1和x2地址相同，其中的元素的地址也相同。
x1 = (1,2,[3,4])
x2 = copy.deepcopy(x1)
x1和x2地址不相同，其中的不可变类型元素的地址相同，可变类型元素的地址不相同。
```

对于可变类型List、Dictionary、Set，深拷贝**会开辟新的空间地址**，进行拷贝，原对象与新对象的**地址不同**。其中所有的**不可变类型元素的地址相同，而可变类型元素都开辟了新的空间，地址不相同**。
深拷贝，除了顶层拷贝，还对子元素也进行了拷贝（本质上递归浅拷贝）。经过深拷贝后，原始对象和拷贝对象**所有的可变类型元素地址都没有相同的了。**

对于list、tuple、dict这些元素可为不可变类型也可为可变类型的对象来说，其中**不可变类型的元素**，深拷贝也只是对原对象的该元素增加了一个引用而已。改变原变量的元素的值（即改变它指向的对象），**不会**对拷贝变量的元素指向的对象造成影响。
对于**可变类型的元素**，深拷贝的新对象与原对象可变类型元素的地址都是**不同的地址**，两者不能相互影响，改变原对象的可变对象元素**不能**对新对象造成影响！

```js
list1 = [11,12]
list2 = copy.deepcopy(list1)
list1 is list2              输出False    
list1[1] is list2[1]        输出True
list1[1] = 10               输出list2 为[11, 12]
tup1 = (1,2,[3,4])
tup2 = copy.deepcopy(tup1)
tup1 is tup2               输出False
tup1[2] is tup2[2]         输出False
tup1[2][1] = 5             输出tup2 为(1, 2, [3, 4])
```


## 其他拷贝方法(尚未验证性质)
另外，list2 = list1[:]这样的**分片表达式**也可以实现对对象的拷贝。此种方式是**浅拷贝！**

**字典**自带有copy()方法，能够实现**深拷贝！**
```js
dic2 = dic1.copy()
```

## 还有一件事！

```js
a = [1,2]
b = a
```
‘=’是赋值运算符，只是将a这一变量存储的list[1,2]的地址值赋给了b这一变量，并没有进行拷贝！

在这里，又重新提一下Python中的变量和对象！

变量没有类型，拥有一定的空间，存的是对象的地址！

对象有类型，由占据的地址空间、数据类型和其中存储的值三部分组成！(这里的数据类型是实实在在的数据类型，如：int、list等，而不是可变类型和不可变类型)


## 引用：


- [Python3浅拷贝与深拷贝的区别和理解](https://www.jianshu.com/p/03dce38cc97e)
