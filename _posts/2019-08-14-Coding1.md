---
layout: post
title:  "刷题之动态规划"
categories: Coding
tags:  基础知识 找工作必备 
author: zyy
---

* content
{:toc}


## 前言

本文主要记录动态规划中的一个常见问题及它的两个拓展！

## 最大子段和问题

### 问题阐述
对于给定的序列a1,a2,...,an,寻找它的某一个连续子段，使得其和最大。如序列：-2,11,-4,13,-5,-2，它的最大子段为11，-4，13，其和为20。




### 枚举法 or 分治法

这个问题用枚举或者分治法也可解，枚举法就是枚举所有的子段，找出其中和最大的，而分治法是将整个序列切为两段，最大连续子段有可能在左半段，有可能在右半段，也有可能是左半段的结尾接上右半段的开头。用递归的方式找出左右半段的最大连续子段，结束条件是子段长度为1。跨立两端的情况就是找出从切口处延伸出去的两个最大值加起来。

### 动态规划

动态规划解决这一问题，关键在于设立一个子段和数组b，其长度与原序列a长度相同，bi用于存储以ai结尾的子段的最大值。

当b[i-1]>0时，b[i] = a[i] + b[i-1];否则，b[i] = a[i]。当b[i-1]<0时，说明以a[i-1]结尾的子段和是负数，b[i]如果加上它只会变小，因此b[i] = a[i]。

当然，这个数组b不一定要显式的定义，因为我们只是在计算bi的时候要用到bi-1，以及找出最大值而已，可以用一个m暂存最大值，b暂存bi-1就够了！
```js
def max_1(l):
    # n = len(l)
    # if n < 1:
    #     return 0
    # b = [l[0]]
    # for i in l[1:]:
    #     if b[-1] > 0:
    #         b.append(b[-1]+i)
    #     else:
    #         b.append(i)
    # return max(b)

    b = float("-inf")
    m = float("-inf")
    for i in l:
        if b > 0:
            b += i
        else:
            b = i
        m = max(m,b)
    return m
```

## 最大子矩阵和问题

### 问题阐述
给定一个m行n列的整数矩阵A，试求A的一个子矩阵，使得子矩阵各元素之和最大。

这个题目要求max(A[i1:i2][j1:j2]),具体分析过程见参考网页（公式太难打了orz）

其实思路就是：先将取哪些行的情况枚举出来，每一种情况里面，每一列的元素对应累加起来，取其中的最大连续子段和，就得到了这一种情况的最大子矩阵了。所有情况的最大值就是要求的最大子矩阵。

```js
def max_2(m):
    r = len(m)   #行数
    if r < 1:
        return 0
    c = len(m[0])   #列数
    if c < 1:
        return 0
    y = float("-inf")    #最大子矩阵和
    for i in range(r):
        b = [0]*c          #b[k]用于存储从第i行到第j行的第k列元素的累加和
        for j in range(i,r):
            for k in range(c):
                b[k] += m[j][k]   #用b数组存值，每当j加一时，将b数组中的对应值加上该行的对应值就好了，而不用每次都从i行到第j行进行累加。
            x = max_1(b)   #调用max_1函数，取b数组的连续子序列最大累加和
            y = max(x,y)
    return y

```


## 最大m段子序列和问题

### 问题阐述
给定由n个整数(可能为负数)组成的序列a1,a2,a3……an,以及一个正整数m,要求确定此序列的m个不相交子段的总和达到最大。最大子段和问题是最大m子段和问题当m=1时的特殊情形。（不一定真的要切成m个子段，只要和最大，段数最多为m）

这个问题需要建一个二维数组b[m][n],其中的每一个元素b[i][j]表示从0-j个元素中挑出i+1（因为i从0开始）个连续子段（元素j必定属于最后一个字段），所有挑选方案的最大值，就是b[i][j]的值。b[i][j]有两种情况，第一种是b[i][j-1]+a[j],表示a[j]被分在最后一个子段中，并且最后一个字段还有其他元素；第二种情况是b[i-1][t]+a[j],其中b[i-1][t]表示前j-1个元素取i-1个子段的最大和，i-1 <= t < j,这种情况意味着a[j]单独组成最后一个子段。

```js

def max_3(l,m):
    # n = len(l)
    # a = [[0]*(n+1) for i in range(m+1)]
    # x = 0
    # for i in range(1,m+1):
    #     z = 0
    #     for j in range(i,n+1):
    #         z = max(z,a[i - 1][j - 1])
    #         a[i][j] = max(a[i][j-1]+l[j-1],z+l[j-1])
    #         x = max(x,a[i][j])
    # return x

    n = len(l)
    a = [[0]*(n+1) for i in range(2)]
    x = 0
    for i in range(1,m+1):
        p = i&1
        q = (i-1)&1
        z = 0
        for j in range(i,n+1):
            z = max(z,a[q][j-1])
            a[p][j] = max(a[p][j-1],z)+l[j-1]
    v = m&1
    for i in range(m,n+1):
        x = max(a[v][i],x)
    return x

```

由于前一种分配方案会包含在后一种方案中，所以其实数组b只要两行就够了！

由于参考网页的要求是必须有m段，而我的代码不要求一定要有m段，所以两者会有些差别！

## 参考
[动态规划---最大子段和，最大子矩阵和，最大m子段和](https://blog.csdn.net/qq_22238021/article/details/78863701)
