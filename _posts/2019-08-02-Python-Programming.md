---
layout: post
title:  "Python编程的盲点与技巧"
categories: Python
tags:  python 基础知识 找工作必备 
author: zyy
---

* content
{:toc}


## 前言

Python编程中有许多需要注意的小知识点，一个不注意，就让你的程序报错或输出不对劲。本帖旨在持续更新一些很容易忽视的小Bug！

## Python2与Python3的区别

Python2的除('/'),当两个操作数都为整数时，默认为**整除**。而Python3不是这样！当python2不想整除时，可以使用**float()**函数将其中一个操作数转化为浮点数！(由于本人习惯使用python3，所以在刷题或者做笔试时，碰到只支持python2的题目的时候，很容易忘记这一点而导致程序输出出错！)

有很多python方法在2.xxx 和3.xxx 中的输出有差别，比如：
* Python 2.x 的map()函数**直接返回列表**。Python 3.x 的map()函数**返回迭代器**，使用**list()函数**可将结果转化为list列表。
* Python 2.x 的zip()函数**直接返回一个由元组组成的列表**。Python 3.x 的zip()函数**返回的是一个对象**，使用**list()函数**可将结果转化为list列表。




Python2的**print没有括号**，而Python3的**print有括号**！


## 编程中要注意的问题：

### Python的负数移位：

**Python的负数，向右移位时，能够无限移位而不会为零！**
```js
while(n):
	n>>1
# 当n为负时，这是个无限循环！
```
所以，除非是**无符号数或者非负整数**，否则不要使用这个循环条件！
具体原因参见：
[关于负数的右移>>与无符号右移>>>运算小结](https://blog.csdn.net/fengqing5578/article/details/88224394)

对于带符号右移,存储时首位表示符号位。若为负数,其符号位为1,在移位过程中,**高位补1**；若符号位是0,表示是正数,在移位过程中**高位补零**,两者的前提是**符号位保持不变**:

对于负数的右移：因为负数在内存中是以补码形式存在的，所有首先根据负数的原码求出负数的补码(**符号位不变，其余位按照原码取反加1**)，然后**保证符号位不变，其余位向右移动到X位，在移动的过程中，高位补1**.等移位完成以后，然后**保持符号位不变，其余按位取反加1，得到移位后所对应数的原码。即为所求。**

### Python的正负无穷：float('inf')、float('-inf')

Python中可以用如下方式表示正负无穷：**float("inf"), float("-inf")**
* 利用 **inf 做简单加、乘算术运算仍会得到 inf**
```js
1 + float('inf')   #inf
2 * float('inf')   #inf
```

* 但是利用** inf 乘以0会得到 not-a-number(NaN)**：
```js
 0 * float("inf")  #nan
```

* **除了inf外的其他数除以inf，会得到0**
```js
889 / float('inf')    #0.0
float('inf')/float('inf')   #nan
```

* **通常的运算是不会得到 inf值的！**

* 当涉及 > 和 < 运算时，**所有数都比-inf大，所有数都比+inf小，+inf 和 +inf相等，-inf 和 -inf相等。**

### Python _、__和__xx__的区别

Python的编程习惯以下划线开头的标识符是有特殊意义的。以单下划线开头的（_foo）代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入；以双下划线开头的（\_\_foo）代表类的私有成员；以双下划线开头和结尾的（\_\_foo\_\_）代表python里特殊方法专用的标识，如__init__（）代表类的构造函数。

#### "_xx"单下划线开头
Python中**没有真正的私有属性或方法**,在你想声明为私有的方法和属性前加上单下划线,以提示该属性和方法不应在外部调用.**如果真的调用了也不会出错,但不符合规范.**

Python中不存在真正的私有方法。为了实现类似于c++中私有方法，可以在类的方法或属性前加一个“_”单下划线，意味着该方法或属性不应该去调用，它并不属于API。

#### "__xx"双下划线
双下划线会造成更多混乱，它并不是用来标识一个方法或属性是私有的，真正作用是用来**避免子类覆盖其内容**。

因此，在我们创建一个以"__"两个下划线开始的方法时，这意味着**这个方法不能被重写，它只允许在该类的内部中使用。**

#### "\_\_xx\_\_"前后各双下划线
当你看到"\_\_this\_\_"的时候，就**不要调用它**。为什么？因为它的意思是它是用于Python调用的。
“\_\_xx\_\_”经常是**操作符或本地函数调用的magic methods。**

在特殊的情况下，它只是python调用的hook。例如，\_\_init\_\_()函数是当对象被创建初始化时调用的;\_\_new\_\_()是用来创建实例。

#### 总结
* 使用_one_underline_head来表示该方法或属性是私有的，不属于API；
* 使用__two_underlines_head，来避免子类的重写！
* 当创建一个用于python调用或一些特殊情况，如子类不能覆盖的那些父类方法时，使用__two_underlines_head&end__；

#### 还有一件事
在交互模式下运行python时，一个下划线字符(_)是特殊标识符，它**保留了表达式的最后一个计算结果**。

在python中，函数、类、模块定义的第一段代码如果是字符串的话，就把它叫作文件字串，**可通过__doc__属性访问**。如:

```js
def test():
"this is a document string"
return 100+1000
>>>print test.__doc__
this is a document string
```

### Python的位运算

**与0按位异或，得到的是原数字，而与1按位异或得到的是第0位取反，而其他位为原值。**

取补码的代码：
```js
if num < 0:
	num = -num
	i = 0
	while(i<32):
		num = num ^ (1<<i)
		i += 1
	num += 1
```

## Python的某些方法的使用：

* 负数在转化为str时，使用isdigit()方法，由于有一个负号在前面，所以返回值是False。（isdigit()方法用于检测字符串是否只由数字组成，如果字符串只包含数字则返回 True 否则返回 False。）

同样的，isalpha() 方法检测字符串是否只由字母组成。 isalnum() 方法检测字符串是否由字母和数字组成。 islower() 方法检测字符串是否由小写字母组成。

* bin()方法返回一个整数 int 或者长整数 long int 的二进制表示，返回值是一个字符串。正数的返回值是原数字的二进制表示前+”0b“，负数的返回值是原数字的绝对值的二进制表示前+”-0b“

* random包中的randint方法的界限与range不同，randint()方法，返回参数范围内的随机整数，并且两个边界的数都是可以取到的。range()方法不能取到右边界。

* python中的list的sort()方法没有返回值，直接在原list上进行了排序，因此不能用于原list不可变的情形。如果某个函数的返回值需要用sort()排序时，要先赋给一个变量，对它进行sort()后，再return。sort()方法默认是升序排列，当设置参数reverse = True 时，降序排列。sort()的另一个参数key，当要排序的list的元素是可迭代对象时（就是list的元素也是list或者dict等包含多个元素的对象时），key可以指定用元素的哪一个子元素进行排序或者指定按何种方法进行排序，比如：按每个元素的第二个子元素排序。key的值是一种方法。

```js
def takeSecond(elem):          # 获取列表的第二个元素
    return elem[1]
 
random = [(2, 2), (3, 4), (4, 1), (1, 3)]
random.sort(key=takeSecond)        # 指定按第二个元素排序
print ('排序列表：', random)

#结果：排序列表：[(4, 1), (2, 2), (1, 3), (3, 4)]
```

* map()会根据提供的函数对指定序列做映射。第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。

```js
>>>def square(x) :            # 计算平方数
       return x ** 2
>>> map(square, [1,2,3,4,5])   # 计算列表各个元素的平方
[1, 4, 9, 16, 25]

>>> map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
 
# 提供了两个列表，对相同位置的列表数据进行相加
>>> map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])
[3, 7, 11, 15, 19]
```

Python 2.x 的map()函数**直接返回列表**。Python 3.x 的map()函数**返回迭代器**，使用**list()函数**可将结果转化为list列表。

* zip()接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。

将zip函数中的两个可迭代对象参数按对应索引值进行匹配组合，得到zip对象。
```js
>>> z1=[1,2,3]
>>> z2=[4,5,6]
>>> result=zip(z1,z2)
>>> result
[(1, 4), (2, 5), (3, 6)]
>>> z3=[4,5,6,7]
>>> result=zip(z1,z3)
>>> result
[(1, 4), (2, 5), (3, 6)]
```
zip()配合*号操作符,可以将已经zip过的列表对象解压
```js
>>> zip(*result)
[(1, 2, 3), (4, 5, 6)]
```
只有一个list的情况：
```js
x = [1, 2, 3]
x = zip(x)
print (x)

运行的结果是：[(1,), (2,), (3,)]
```

二维矩阵变换（矩阵的行列互换）
```js
a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]            #由列表描述的二维矩阵
print [ [row[col] for row in a] for col in range(len(a[0]))]     #通过python列表推导的方法
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]

利用zip函数
>>> a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> zip(*a)        # 在a之前加一个*，使它变成一个个的行向量，zip将各个行向量打包。不加*的话，只会把一个这个矩阵的行向量当成一个整体。
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
>>> map(list,zip(*a))
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]


zip(a)
[([1, 2, 3],), ([4, 5, 6],), ([7, 8, 9],)]

```

Python 2.x 的zip()函数**直接返回一个由元组组成的列表**。Python 3.x 的zip()函数**返回的是一个对象**，使用**list()函数**可将结果转化为list列表。


## 引用
* [Python 关于正负无穷float(‘inf’)的一些用法](https://blog.csdn.net/shennongzhaizhu/article/details/51997887)

* [python _、__和__xx__的区别](https://blog.csdn.net/helloxiaozhe/article/details/80534894)